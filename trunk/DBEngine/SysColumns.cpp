// Sys Columns....

#include"SysColumns.h"

//using namespace std;

/*class SysColumnsEntry
{
	private: string _dbName; // Name of the database 64 bytes long
		 string _tableName; // Name of the table 64 bytes long
		 string _columnName; // Name of the column 64 bytes long
		 int _ordinalPosition; // Position of the column in the row
		 string _columnDefault; // Default value // Length has to be specified.... 256 bytes long
		 char _isNullable; // Indicates whether the column can have NULL values or not
		 string _dataType; // Data Type of the column // 8 bytes long
		 //string _columnType; // Column type
		 // string _columnKey; // If it is part of a key or not Redundant because of _keyPos variable
		 int _length; // Length of the column
		 short _scale; // Scale of the column - Needed for precision.... Decimal, Timestamp with/wo Time zone
		 char _updatable; // Whether the column is updatable or not
		 string _remarks; // Remarks for the column.... 256 bytes long
		 short _keyPos; // Position in the key.... 0 if not part of primary key
		 char _foreignKey; // Whether it is a foreign key or not
		 char _generatedAttribute; // A if generated always or D if generated by Default value or blank
		 char _hidden; // If its hidden or not when select * query is run
		 //int _cID; // Not using this as of now

		 static int _colID;


	public: SysColumnsEntry()
		{
			_dbName = "Database Name";
			_tableName = "Table Name";
			_columnName = "Column Name";
			_ordinalPosition = -1;
			_columnDefault = "\0";
			_isNullable = 'Y';
			_dataType = "\0";
			_length = -1;
			_scale = 0;
			_updatable = 'Y';
			_remarks ="\0";
			_keyPos = 0;
			_foreignKey = 'N';
			_generatedAttribute = ' ';
			_hidden = 'N';
		}

		~SysColumnsEntry()
		{
			// Destructor for SysColumnsEntry
		}

		static SysColumnsEntry * getSysColumnsEntry()
		{
			return new SysColumnsEntry();
		}

		static int next_sysColumnsEntry_id()
		{
			_colID++;
			return _colID;
		}
};
*/

string SysColumnsEntry::getTableName()
{
	return _tableName;
}

void SysColumnsEntry::setTableName(string _tableName)
{
	this->_tableName = _tableName;
}

string SysColumnsEntry::getDBName()
{
	return _dbName;
}

void SysColumnsEntry::setDBName(string _dbName)
{
	this->_dbName = _dbName;
}

string SysColumnsEntry::getColumnName()
{
	return _columnName;
}

void SysColumnsEntry::setColumnName(string _columnName)
{
	this->_columnName = _columnName;
}

string SysColumnsEntry::getColumnDefault()
{
	return _columnDefault;
}

void SysColumnsEntry::setColumnDefault(string _columnDefault)
{
	this->_columnDefault = _columnDefault;
}

string SysColumnsEntry::getDataType()
{
	return _dataType;
}

void SysColumnsEntry::setDataType(string _dataType)
{
	this->_dataType = _dataType;
}

string SysColumnsEntry::getRemarks()
{
	return _remarks;
}

void SysColumnsEntry::setRemarks(string _remarks)
{
	this->_remarks = _remarks;
}

char SysColumnsEntry::getIsNullable()
{
	return _isNullable;
}

void SysColumnsEntry::setIsNullable(char _isNullable)
{
	this->_isNullable = _isNullable;
}

char SysColumnsEntry::getUpdatable()
{
	return _updatable;
}

void SysColumnsEntry::setUpdatable(char _updatable)
{
	this->_updatable = _updatable;
}

char SysColumnsEntry::getForeignKey()
{
	return _foreignKey;
}

void SysColumnsEntry::setForeignKey(char _foreignKey)
{
	this->_foreignKey = _foreignKey;
}

char SysColumnsEntry::getGeneratedAttribute()
{
	return _generatedAttribute;
}

void SysColumnsEntry::setGeneratedAttribute(char _generatedAttribute)
{
	this->_generatedAttribute = _generatedAttribute;
}

char SysColumnsEntry::getHidden()
{
	return _hidden;
}

void SysColumnsEntry::setHidden(char _hidden)
{
	this->_hidden = _hidden;
}

short SysColumnsEntry::getScale()
{
	return _scale;
}

void SysColumnsEntry::setScale(short _scale)
{
	this->_scale = _scale;
}

short SysColumnsEntry::getKeyPos()
{
	return _keyPos;
}

void SysColumnsEntry::setKeyPos(short _keyPos)
{
	this->_keyPos = _keyPos;
}

int SysColumnsEntry::getOrdinalPosition()
{
	return _ordinalPosition;
}

void SysColumnsEntry::setOrdinalPosition(int _ordinalPosition)
{
	this->_ordinalPosition = _ordinalPosition;
}

int SysColumnsEntry::getLength()
{
	return _length;
}

void SysColumnsEntry::setLength(int _length)
{
	this->_length = _length;
}

int SysColumnsEntry::fillBuffer(char *entryBuffer)
{
	char * tabNameBuf = new char [64];
	char * dbNameBuf = new char [64];
	char * colNameBuf = new char [64];
	char * dataTypeBuf = new char [8];
	char * remarksBuf = new char [256];
	char * columnDefaultBuf = new char [256];

	for(int i = 0;i<64;i++)
	{
		tabNameBuf[i] = '$';
		dbNameBuf[i] = '$';
		colNameBuf[i] = '$';
	}
	for(int i = 0;i<256;i++)
	{
		remarksBuf[i] = '$';
		columnDefaultBuf[i] = '$';
	}
	for(int i=0;i<8;i++)
	{
		dataTypeBuf[i] = '$';
	}

	//const char * tabNameBuf1 = _tableName.c_str();
	//const char * dbNameBuf1 = _dbName.c_str();
	//const char * remarksBuf1 = _remarks.c_str();

	int len = _tableName.length();

	for(int i = 0;i<len;i++)
	{
		tabNameBuf[i] = _tableName[i];
	}
	len = _dbName.length();
	for(int i = 0;i<len;i++)
	{
		dbNameBuf[i] = _dbName[i];
	}
	len = _remarks.length();
	for(int i = 0;i<len;i++)
	{
		remarksBuf[i] = _remarks[i];
	}
	len = _columnName.length();
	for(int i = 0;i<len;i++)
	{
		colNameBuf[i] = _columnName[i];
	}
	len = _columnDefault.length();
	for(int i = 0;i<len;i++)
	{
		columnDefaultBuf[i] = _columnDefault[i];
	}
	len = _dataType.length();
	for(int i = 0;i<len;i++)
	{
		dataTypeBuf[i] = _dataType[i];
	}
	memcpy(&entryBuffer[SYSCOLTABLENAMEPTR],tabNameBuf,64*sizeof(char));
	/*cout<<"Buffer contents: From "<<TABLENAMEPTR<<" to "<<TABLENAMEPTR+64<<" : ";
	for(int i = TABLENAMEPTR;i<64;i++)
	{
		cout<<entryBuffer[i];
	}
	cout<<endl;*/
	memcpy(&entryBuffer[SYSCOLDBNAMEPTR],dbNameBuf,64*sizeof(char));
	/*cout<<"Buffer contents: From "<<DBNAMEPTR<<" to "<<DBNAMEPTR+64<<" : ";
	for(int i = DBNAMEPTR;i<DBNAMEPTR+64;i++)
	{
		cout<<entryBuffer[i];
	}
	cout<<endl;*/
	memcpy(&entryBuffer[SYSCOLCOLNAMEPTR],colNameBuf,64*sizeof(char));
	/*cout<<"Buffer contents: From "<<COLNAMEPTR<<" to "<<COLNAMEPTR+64<<" : ";
	for(int i = COLNAMEPTR;i<COLNAMEPTR+64;i++)
	{
		cout<<entryBuffer[i];
	}
	cout<<endl;*/
	memcpy(&entryBuffer[SYSCOLORDPOSPTR],&_ordinalPosition,sizeof(int));
	/*cout<<"Buffer contents: From "<<ORDPOSPTR<<" to "<<ORDPOSPTR+sizeof(int)<<" : ";
	for(int i = ORDPOSPTR;i<ORDPOSPTR+sizeof(int);i++)
	{
		cout<<entryBuffer[i];
	}
	cout<<endl;*/
	memcpy(&entryBuffer[SYSCOLCOLDEFPTR],columnDefaultBuf,256*sizeof(char));
	/*cout<<"Buffer contents: From "<<COLDEFPTR<<" to "<<COLDEFPTR+256<<" : ";
	for(int i = COLDEFPTR;i<COLDEFPTR+256;i++)
	{
		cout<<entryBuffer[i];
	}
	cout<<endl;*/
	memcpy(&entryBuffer[SYSCOLISNULLPTR],&_isNullable,sizeof(char));
	/*cout<<"Buffer contents: From "<<ISNULLPTR<<" to "<<ISNULLPTR+sizeof(char)<<" : ";
	for(int i = ISNULLPTR;i<ISNULLPTR+sizeof(char);i++)
	{
		cout<<entryBuffer[i];
	}
	cout<<endl;*/
	memcpy(&entryBuffer[SYSCOLDATATYPEPTR],dataTypeBuf,8*sizeof(char));
	/*cout<<"Buffer contents: From "<<DATATYPEPTR<<" to "<<DATATYPEPTR+8<<" : ";
	for(int i = DATATYPEPTR;i<DATATYPEPTR+8;i++)
	{
		cout<<entryBuffer[i];
	}
	cout<<endl;*/
	memcpy(&entryBuffer[SYSCOLLENPTR],&_length,sizeof(int));
	/*for(int i = LENPTR;i<LENPTR+sizeof(int);i++)
	{
		cout<<entryBuffer[i];
	}
	cout<<endl;*/
	memcpy(&entryBuffer[SYSCOLSCALEPTR],&_scale,sizeof(short));
	/*for(int i = SCALEPTR;i<SCALEPTR+sizeof(short);i++)
	{
		cout<<entryBuffer[i];
	}
	cout<<endl;*/
	memcpy(&entryBuffer[SYSCOLUPDATABLEPTR],&_updatable,sizeof(char));
	/*cout<<"Buffer contents: From "<<UPDATABLEPTR<<" to "<<UPDATABLEPTR+sizeof(char)<<" : ";
	for(int i = UPDATABLEPTR;i<UPDATABLEPTR+sizeof(char);i++)
	{
		cout<<entryBuffer[i];
	}
	cout<<endl;*/
	memcpy(&entryBuffer[SYSCOLREMARKSPTR],remarksBuf,256*sizeof(char));
	/*cout<<"Buffer contents: From "<<REMARKSPTR<<" to "<<REMARKSPTR+256<<" : ";
	for(int i = REMARKSPTR;i<REMARKSPTR+256;i++)
	{
		cout<<entryBuffer[i];
	}
	cout<<endl;*/
	memcpy(&entryBuffer[SYSCOLKEYPOSPTR],&_keyPos,sizeof(short));
	/*for(int i = KEYPOSPTR;i<KEYPOSPTR+sizeof(short);i++)
	{
		cout<<entryBuffer[i];
	}
	cout<<endl;*/
	memcpy(&entryBuffer[SYSCOLFORKEYPTR],&_foreignKey,sizeof(char));
	/*cout<<"Buffer contents: From "<<FORKEYPTR<<" to "<<FORKEYPTR+sizeof(char)<<" : ";
	for(int i = FORKEYPTR;i<FORKEYPTR+sizeof(char);i++)
	{
		cout<<entryBuffer[i];
	}
	cout<<endl;*/
	memcpy(&entryBuffer[SYSCOLGENATTRPTR],&_generatedAttribute,sizeof(char));
	/*cout<<"Buffer contents: From "<<GENATTRPTR<<" to "<<GENATTRPTR+sizeof(char)<<" : ";
	for(int i = GENATTRPTR;i<GENATTRPTR+sizeof(char);i++)
	{
		cout<<entryBuffer[i];
	}
	cout<<endl;*/
	memcpy(&entryBuffer[SYSCOLHIDDENPTR],&_hidden,sizeof(char));
	/*cout<<"Buffer contents: From "<<HIDDENPTR<<" to "<<HIDDENPTR+sizeof(char)<<" : ";
	for(int i = HIDDENPTR;i<HIDDENPTR+sizeof(char);i++)
	{
		cout<<entryBuffer[i];
	}
	cout<<endl;*/

	//string s1 = string(entryBuffer);

	delete tabNameBuf;
	delete dbNameBuf;
	delete remarksBuf;
	delete colNameBuf;
	delete columnDefaultBuf;
	delete dataTypeBuf;

	return 1;
}

int SysColumnsEntry::getDataBuffer(char *entryBuffer)
{
	char * tabNameBuf = new char [64];
	char * dbNameBuf = new char [64];
	char * colNameBuf = new char [64];
	char * remarksBuf = new char [256];
	char * columnDefaultBuf = new char [256];
	char * dataTypeBuf = new char [8];

	memcpy(tabNameBuf,&entryBuffer[SYSCOLTABLENAMEPTR],64*sizeof(char));
	memcpy(dbNameBuf,&entryBuffer[SYSCOLDBNAMEPTR],64*sizeof(char));
	memcpy(colNameBuf,&entryBuffer[SYSCOLCOLNAMEPTR],64*sizeof(char));
	memcpy(&_ordinalPosition,&entryBuffer[SYSCOLORDPOSPTR],sizeof(int));
	memcpy(columnDefaultBuf,&entryBuffer[SYSCOLCOLDEFPTR],256*sizeof(char));
	memcpy(&_isNullable,&entryBuffer[SYSCOLISNULLPTR],sizeof(char));
	memcpy(dataTypeBuf,&entryBuffer[SYSCOLDATATYPEPTR],8*sizeof(char));
	memcpy(&_length,&entryBuffer[SYSCOLLENPTR],sizeof(int));
	memcpy(&_scale,&entryBuffer[SYSCOLSCALEPTR],sizeof(short));
	memcpy(&_updatable,&entryBuffer[SYSCOLUPDATABLEPTR],sizeof(char));
	memcpy(remarksBuf,&entryBuffer[SYSCOLREMARKSPTR],256*sizeof(char));
	memcpy(&_keyPos,&entryBuffer[SYSCOLKEYPOSPTR],sizeof(short));
	memcpy(&_foreignKey,&entryBuffer[SYSCOLFORKEYPTR],sizeof(char));
	memcpy(&_generatedAttribute,&entryBuffer[SYSCOLGENATTRPTR],sizeof(char));
	memcpy(&_hidden,&entryBuffer[SYSCOLHIDDENPTR],sizeof(char));

	_tableName = "";
	_dbName = "";
	_columnName = "";
	_remarks = "";
	_columnDefault = "";
	_dataType = "";
	for(int i=0;i<64;i++)
	{
		if(tabNameBuf[i] == '$')
			break;
		_tableName = _tableName+tabNameBuf[i];
	}
	for(int i=0;i<64;i++)
	{
		if(dbNameBuf[i] == '$')
			break;
		_dbName = _dbName+dbNameBuf[i];
	}
	for(int i=0;i<64;i++)
	{
		if(colNameBuf[i] == '$')
			break;
		_columnName = _columnName+colNameBuf[i];
	}
	for(int i=0;i<256;i++)
	{
		if(remarksBuf[i] == '$')
			break;
		_remarks = _remarks+remarksBuf[i];
	}
	for(int i=0;i<256;i++)
	{
		if(columnDefaultBuf[i] == '$')
			break;
		_columnDefault = _columnDefault+columnDefaultBuf[i];
	}
	for(int i=0;i<8;i++)
	{
		if(dataTypeBuf[i] == '$')
			break;
		_dataType = _dataType+dataTypeBuf[i];
	}

	delete tabNameBuf;
	delete dbNameBuf;
	delete remarksBuf;
	delete colNameBuf;
	delete columnDefaultBuf;
	delete dataTypeBuf;
}


//int SysColumnsEntry::_colID = 0;

/*class SysColumns
{
	private: int _pageID;
		 short _pagePriority;
		 int _nextSysColumnsPage;
		 int _curSysColumnsSize; // Check this is not required... This can be got by METADATASIZE + noe*COLUMNENTRYSIZE
		 int _remSysColumnsSize;
		 long _sysColumnsEntryPointer;
		 int _noOfEntries;
		 int _pageSize;

	public: SysColumns()
		{
			_pagePriority = 50;
			_nextSysColumnsPage = -1;
			_pageID = 3;
			_curSysColumnsSize = SYSCOLUMNMETADATASIZE;
			_remSysColumnsSize = SYSCOLUMNENTRYSPACE;
			_sysColumnsEntryPointer = 0;
			_noOfEntries = 0;
		}

		SysColumns(int pageID)
		{
			_pagePriority = 50;
			_nextSysColumnsPage = -1;
			_pageID = pageID;
			_curSysColumnsSize = SYSCOLUMNMETADATASIZE;
			_remSysColumnsSize = SYSCOLUMNENTRYSPACE;
			_sysColumnsEntryPointer = 0;
			_noOfEntries = 0;
		}

		SysColumns(char *buffer)
		{
			memcpy(&_pageID,&buffer[PAGEIDPTR],sizeof(int));
			memcpy(&_pagePriority,&buffer[PAGEPRIPTR],sizeof(short));
			memcpy(&_nextSysColumnsPage,&buffer[NEXTPTR],sizeof(int));
			memcpy(&_curSysColumnsSize,&buffer[CURSYSCOLSIZEPTR],sizeof(int));
			memcpy(&_remSysColumnsSize,&buffer[REMSYSCOLSIZEPTR],sizeof(int));
			memcpy(&_sysColumnsEntryPointer,&buffer[SYSCOLUMNENTRYPTR],sizeof(long));
			memcpy(&_noOfEntries,&buffer[SYSCOLNOEPTR],sizeof(int));
		}

		~SysColumns()
		{
			// Destructor for SysColumns
		};


		static SysColumns * newSysColumns()
		{
			return new SysColumns();
		}

		static SysColumns * newSysColumns(int pageID)
		{
			return new SysColumns(pageID);
		}

		static SysColumns * newSysColumns(char *buffer)
		{
			return new SysColumns(buffer);
		}
};
*/

int SysColumns::getpageID()
{
	return _pageID;
}

void SysColumns::setpageID(int pageID)
{
	_pageID = pageID;
}

short SysColumns::getpagePriority()
{
	return _pagePriority;
}

void SysColumns::setpagePriority(short pagePriority)
{
	_pagePriority = pagePriority;
}

int SysColumns::getnextSysColumnsPage()
{
	return _nextSysColumnsPage;
}

void SysColumns::setnextSysColumnsPage(int nextSysColumnsPage)
{
	_nextSysColumnsPage = nextSysColumnsPage;
}

int SysColumns::getCurSysColumnsSize()
{
	return _curSysColumnsSize;
}

void SysColumns::setCurSysColumnsSize(int curSysColumnsSize)
{
	_curSysColumnsSize = curSysColumnsSize;
}

int SysColumns::getRemSysColumnsSize()
{
	return _remSysColumnsSize;
}

void SysColumns::setRemSysColumnsSize(int remSysColumnsSize)
{
	_remSysColumnsSize = remSysColumnsSize;
}

long SysColumns::getSysColumnsEntryPointer()
{
	return _sysColumnsEntryPointer;
}

void SysColumns::setSysColumnsEntryPointer(long sysColumnsEntryPointer)
{
	_sysColumnsEntryPointer = sysColumnsEntryPointer;
}

int SysColumns::getNoOfEntries()
{
	return _noOfEntries;
}

void SysColumns::setNoOfEntries(int noOfEntries)
{
	_noOfEntries = noOfEntries;
}

int SysColumns::getPageSize()
{
	return _pageSize;
}

void SysColumns::setPageSize(int pageSize)
{
	_pageSize = pageSize;
}

void SysColumns::writeSysColumnsBuffer(char *buffer)
{
	//char *buffer = new char [_pageSize];
	int result;

	/*result = pageRead(_pageID,buffer); // From Chinmay, get buffer and page from cache........
	if(result == -1)
	{
		cout<<"Page could not be read...."<<endl;
		return -1;
	}*/

	cout<<"Object contents....: "<<endl;
	cout<<"Remaining size: "<<this->getRemSysColumnsSize()<<endl;
	cout<<"MetaData Size: "<<SYSCOLUMNMETADATASIZE<<endl;
	cout<<"Entry Space: "<<SYSCOLUMNENTRYSPACE<<endl;
	cout<<"Page Size: "<<PAGESIZE<<endl;

	// Copying contents to buffer.....
	cout<<"PageID PTR: "<<PAGEIDPTR<<" Value: "<<_pageID<<endl;
	memcpy(&buffer[PAGEIDPTR],&_pageID,sizeof(int));
	cout<<"PagePriority PTR: "<<PAGEPRIPTR<<" Value: "<<_pagePriority<<endl;
	memcpy(&buffer[PAGEPRIPTR],&_pagePriority,sizeof(short));
	cout<<"Next PTR: "<<NEXTPTR<<" Value: "<<_nextSysColumnsPage<<endl;
	memcpy(&buffer[NEXTPTR],&_nextSysColumnsPage,sizeof(int));
	cout<<"CurrentSysColSize PTR: "<<CURSYSCOLSIZEPTR<<" Value: "<<_curSysColumnsSize<<endl;
	memcpy(&buffer[CURSYSCOLSIZEPTR],&_curSysColumnsSize,sizeof(int));
	cout<<"RemSysColSize PTR: "<<REMSYSCOLSIZEPTR<<" Value: "<<_remSysColumnsSize<<endl;
	memcpy(&buffer[REMSYSCOLSIZEPTR],&_remSysColumnsSize,sizeof(int));
	cout<<"SysColEntry PTR: "<<SYSCOLUMNENTRYPTR<<" Value: "<<_sysColumnsEntryPointer<<endl;
	memcpy(&buffer[SYSCOLUMNENTRYPTR],&_sysColumnsEntryPointer,sizeof(long));
	cout<<"NoOfEnt PTR: "<<SYSCOLNOEPTR<<" Value: "<<_noOfEntries<<endl;
	memcpy(&buffer[SYSCOLNOEPTR],&_noOfEntries,sizeof(int));

	// WriteBuffer.... Chinmay's function call here.....
	/*result = pageWrite(_pageID,buffer);

	if(result == -1)
	{
		cout<<"Page could not be read...."<<endl;
		return -1;
	}
	return _pageSize;*/
	return;
}
/*
int SysColumns::writeSysColumnsBuffer(char *buffer)
{
	// WriteBuffer.... Chinmay's function call here.....
	// After inserting a new entry this function is called.....
	int result = pageWrite(_pageID,buffer);

	if(result == -1)
	{
		cout<<"Page could not be read...."<<endl;
		return -1;
	}
	return _pageSize;
}*/

bool SysColumns::checkEntryInsertion()
{
	if(SYSCOLUMNENTRYSIZE + SYSCOLSLOTSIZE > _remSysColumnsSize)
		return 0;
	else
		return 1;
}

int SysColumns::createNewSysColumnEntry(char *entryBuffer,char *sysColumnBuffer)
{
	if(checkEntryInsertion() == 0)
		return -1; // SysColumn entry cannot be inserted, have to create a new SysColumnPage and then add the entry
	else
	{
		//SysColumnsEntry * sysColumnEntry = new SysColumnsEntry();
		// Write code to check for insertion in deleted slots....

		memcpy(&sysColumnBuffer[_sysColumnsEntryPointer],entryBuffer,SYSCOLUMNENTRYSIZE);

		// Updating the SysColumn sizes... Current SysColumnSize increases by EntrySize and RemainingSize decreases by same amount
		_curSysColumnsSize = _curSysColumnsSize + SYSCOLUMNENTRYSIZE + SYSCOLSLOTSIZE;
		_remSysColumnsSize = _remSysColumnsSize - SYSCOLUMNENTRYSIZE - SYSCOLSLOTSIZE;

		_noOfEntries = _noOfEntries + 1;
		_sysColumnsEntryPointer = _sysColumnsEntryPointer + SYSCOLUMNENTRYSIZE;

		memcpy(&sysColumnBuffer[CURSYSCOLSIZEPTR],&_curSysColumnsSize,sizeof(int));
		memcpy(&sysColumnBuffer[REMSYSCOLSIZEPTR],&_remSysColumnsSize,sizeof(int));
		memcpy(&sysColumnBuffer[SYSCOLNOEPTR],&_noOfEntries,sizeof(int));
		memcpy(&sysColumnBuffer[SYSCOLUMNENTRYPTR],&_sysColumnsEntryPointer,sizeof(long));
		// Write SysColumn entry to the buffer of this SysColumnPage

		//delete sysColumnEntry;
		char inserted = '1';
		if(_noOfEntries - 1 == 0)
			memcpy(&sysColumnBuffer[FIRSTSYSCOLSLOTPTR],&inserted,sizeof(char));
		else
			memcpy(&sysColumnBuffer[FIRSTSYSCOLSLOTPTR-((_noOfEntries-1)*sizeof(char))],&inserted,sizeof(char));
		return 1; // SysColumnEntry can be added
	}
}

// Check if I can write it as a list of SysColumnEntry objects instead of passing the buffer around.......

int SysColumns::deleteSysColumnEntry(string columnName,char * sysColumnBuffer)
{
	// Subtract the pointer by SysColumnEntrysize
	// Decrement the no. of SysColumnEntries

	bool found = 0;
	int entryID,i;
	char alreadyDeleted;

	for(i = 0;i<_noOfEntries;i++)
	{
		memcpy(&alreadyDeleted,&sysColumnBuffer[FIRSTSYSCOLSLOTPTR-(i*SYSCOLSLOTSIZE)],SYSCOLSLOTSIZE);

		if(alreadyDeleted == '0')
		{
			cout<<"The entry is deleted... Don't search there.....";
			continue;
		}

		char * newEntryBuff = new char [SYSCOLUMNENTRYSIZE];

		memcpy(newEntryBuff,&sysColumnBuffer[0+(i*SYSCOLUMNENTRYSIZE)],SYSCOLUMNENTRYSIZE);

		char * colName = new char [64];

		memcpy(colName,&newEntryBuff[SYSCOLCOLNAMEPTR],64*sizeof(char));

		string entryColumnName;
		for(int j=0;j<64;j++)
		{
			if(colName[j] == '$')
				break;
			entryColumnName = entryColumnName+colName[j];
		}

		if(columnName == entryColumnName)
		{
			found = 1;
			entryID = i;
			delete colName;
			delete newEntryBuff;
			break;
		}

		delete colName;
		delete newEntryBuff;
	}

	if(found == 0)
	{
		cout<<"Column not found... Continue searching..."<<endl;
		return -1;// Entry not found
	}

	alreadyDeleted = '0';
	memcpy(&sysColumnBuffer[FIRSTSYSCOLSLOTPTR-(i*SYSCOLSLOTSIZE)],&alreadyDeleted,SYSCOLSLOTSIZE);
	return i+1; // SysColumnEntry found Deleted at (i+1)th Slot
}

int SysColumns::deleteSysColumnEntry(string columnName,string tableName,char * sysColumnBuffer)
{
	// Subtract the pointer by SysColumnEntrysize
	// Decrement the no. of SysColumnEntries

	bool found = 0;
	int entryID,i;
	char alreadyDeleted;

	for(i = 0;i<_noOfEntries;i++)
	{
		memcpy(&alreadyDeleted,&sysColumnBuffer[FIRSTSYSCOLSLOTPTR-(i*SYSCOLSLOTSIZE)],SYSCOLSLOTSIZE);

		if(alreadyDeleted == '0')
		{
			cout<<"The entry is deleted... Don't search there.....";
			continue;
		}

		char * newEntryBuff = new char [SYSCOLUMNENTRYSIZE];

		memcpy(newEntryBuff,&sysColumnBuffer[0+(i*SYSCOLUMNENTRYSIZE)],SYSCOLUMNENTRYSIZE);

		char * colName = new char [64];
		char * tabName = new char [64];
		
		memcpy(colName,&newEntryBuff[SYSCOLCOLNAMEPTR],64*sizeof(char));
		memcpy(tabName,&newEntryBuff[SYSCOLTABLENAMEPTR],64*sizeof(char));
		
		string entryColumnName,entryTableName;
		for(int j=0;j<64;j++)
		{
			if(colName[j] == '$')
				break;
			entryColumnName = entryColumnName+colName[j];
		}
		for(int j=0;j<64;j++)
		{
			if(tabName[j] == '$')
				break;
			entryTableName = entryTableName+tabName[j];
		}
		
		if(columnName == entryColumnName && entryTableName == tableName)
		{
			found = 1;
			entryID = i;
			delete colName;
			delete tabName;
			delete newEntryBuff;
			break;
		}

		delete colName;
		delete tabName;
		delete newEntryBuff;
	}

	if(found == 0)
	{
		cout<<"Column not found... Continue searching..."<<endl;
		return -1;// Entry not found
	}

	alreadyDeleted = '0';
	memcpy(&sysColumnBuffer[FIRSTSYSCOLSLOTPTR-(i*SYSCOLSLOTSIZE)],&alreadyDeleted,SYSCOLSLOTSIZE);
	return i+1; // SysColumnEntry found Deleted at (i+1)th Slot
}

int SysColumns::deleteSysColumnEntry(string columnName,string tableName,string dbName,string dataType,char * sysColumnBuffer)
{
	// Subtract the pointer by SysColumnEntrysize
	// Decrement the no. of SysColumnEntries

	bool found = 0;
	int entryID,i;
	char alreadyDeleted;

	for(i = 0;i<_noOfEntries;i++)
	{
		memcpy(&alreadyDeleted,&sysColumnBuffer[FIRSTSYSCOLSLOTPTR-(i*SYSCOLSLOTSIZE)],SYSCOLSLOTSIZE);

		if(alreadyDeleted == '0')
		{
			cout<<"The entry is deleted... Don't search there.....";
			continue;
		}

		char * newEntryBuff = new char [SYSCOLUMNENTRYSIZE];

		memcpy(newEntryBuff,&sysColumnBuffer[0+(i*SYSCOLUMNENTRYSIZE)],SYSCOLUMNENTRYSIZE);

		char * colName = new char [64];
		char * tabName = new char [64];
		char * dataBaseName = new char [64];
		char * dataType = new char [8];

		memcpy(colName,&newEntryBuff[SYSCOLCOLNAMEPTR],64*sizeof(char));
		memcpy(tabName,&newEntryBuff[SYSCOLTABLENAMEPTR],64*sizeof(char));
		memcpy(dataBaseName,&newEntryBuff[SYSCOLDBNAMEPTR],64*sizeof(char));
		memcpy(dataType,&newEntryBuff[SYSCOLDATATYPEPTR],8*sizeof(char));

		string entryColumnName,entryTableName,entryDBName,entryDataType;
		for(int j=0;j<64;j++)
		{
			if(colName[j] == '$')
				break;
			entryColumnName = entryColumnName+colName[j];
		}
		for(int j=0;j<64;j++)
		{
			if(tabName[j] == '$')
				break;
			entryTableName = entryTableName+tabName[j];
		}
		for(int j=0;j<64;j++)
		{
			if(dataBaseName[j] == '$')
				break;
			entryDBName = entryDBName+dataBaseName[j];
		}
		for(int j=0;j<8;j++)
		{
			if(dataType[j] == '$')
				break;
			entryDataType = entryDataType+dataType[j];
		}

		if(columnName == entryColumnName && entryTableName == tableName && entryDBName == dbName && entryDataType == dataType)
		{
			found = 1;
			entryID = i;
			delete colName;
			delete tabName;
			delete dataBaseName;
			delete dataType;
			delete newEntryBuff;
			break;
		}

		delete colName;
		delete tabName;
		delete dataBaseName;
		delete dataType;
		delete newEntryBuff;
	}

	if(found == 0)
	{
		cout<<"Column not found... Continue searching..."<<endl;
		return -1;// Entry not found
	}

	alreadyDeleted = '0';
	memcpy(&sysColumnBuffer[FIRSTSYSCOLSLOTPTR-(i*SYSCOLSLOTSIZE)],&alreadyDeleted,SYSCOLSLOTSIZE);
	return i+1; // SysColumnEntry found Deleted at (i+1)th Slot
}

int SysColumns::searchSysColumnEntry(string columnName,char * sysColumnBuffer)
{
	// Same as delete function instead of marking the deleted flag, just return (i+1) position

	bool found = 0;
	int entryID,i;
	char alreadyDeleted;

	for(i = 0;i<_noOfEntries;i++)
	{
		memcpy(&alreadyDeleted,&sysColumnBuffer[FIRSTSYSCOLSLOTPTR-(i*SYSCOLSLOTSIZE)],SYSCOLSLOTSIZE);

		if(alreadyDeleted == '0')
		{
			cout<<"The entry is deleted... Don't search there.....";
			continue;
		}

		char * newEntryBuff = new char [SYSCOLUMNENTRYSIZE];

		memcpy(newEntryBuff,&sysColumnBuffer[0+(i*SYSCOLUMNENTRYSIZE)],SYSCOLUMNENTRYSIZE);

		char * colName = new char [64];

		memcpy(colName,&newEntryBuff[SYSCOLCOLNAMEPTR],64*sizeof(char));

		string entryColumnName;
		for(int j=0;j<64;j++)
		{
			if(colName[j] == '$')
				break;
			entryColumnName = entryColumnName+colName[j];
		}

		if(columnName == entryColumnName)
		{
			found = 1;
			entryID = i;
			delete colName;
			delete newEntryBuff;
			break;
		}

		delete colName;
		delete newEntryBuff;
	}

	if(found == 0)
	{
		cout<<"Column not found... Continue searching..."<<endl;
		return -1;// Entry not found
	}

	return i+1; // SysColumnEntry found at (i+1)th Slot
}

int SysColumns::searchSysColumnEntry(string columnName,string tableName,char * sysColumnBuffer)
{
	// Subtract the pointer by SysColumnEntrysize
	// Decrement the no. of SysColumnEntries

	bool found = 0;
	int entryID,i;
	char alreadyDeleted;

	for(i = 0;i<_noOfEntries;i++)
	{
		memcpy(&alreadyDeleted,&sysColumnBuffer[FIRSTSYSCOLSLOTPTR-(i*SYSCOLSLOTSIZE)],SYSCOLSLOTSIZE);

		if(alreadyDeleted == '0')
		{
			cout<<"The entry is deleted... Don't search there.....";
			continue;
		}

		char * newEntryBuff = new char [SYSCOLUMNENTRYSIZE];

		memcpy(newEntryBuff,&sysColumnBuffer[0+(i*SYSCOLUMNENTRYSIZE)],SYSCOLUMNENTRYSIZE);

		char * colName = new char [64];
		char * tabName = new char [64];
		
		memcpy(colName,&newEntryBuff[SYSCOLCOLNAMEPTR],64*sizeof(char));
		memcpy(tabName,&newEntryBuff[SYSCOLTABLENAMEPTR],64*sizeof(char));
		
		string entryColumnName,entryTableName;
		for(int j=0;j<64;j++)
		{
			if(colName[j] == '$')
				break;
			entryColumnName = entryColumnName+colName[j];
		}
		for(int j=0;j<64;j++)
		{
			if(tabName[j] == '$')
				break;
			entryTableName = entryTableName+tabName[j];
		}

		if(columnName == entryColumnName && entryTableName == tableName)
		{
			found = 1;
			entryID = i;
			delete colName;
			delete tabName;
			delete newEntryBuff;
			break;
		}

		delete colName;
		delete tabName;
		delete newEntryBuff;
	}

	if(found == 0)
	{
		cout<<"Column not found... Continue searching..."<<endl;
		return -1;// Entry not found
	}

	return i+1; // SysColumnEntry found at (i+1)th Slot
}

int SysColumns::searchSysColumnEntry(string columnName,string tableName,string dbName,string dataType,char * sysColumnBuffer)
{
	// Subtract the pointer by SysColumnEntrysize
	// Decrement the no. of SysColumnEntries

	bool found = 0;
	int entryID,i;
	char alreadyDeleted;

	for(i = 0;i<_noOfEntries;i++)
	{
		memcpy(&alreadyDeleted,&sysColumnBuffer[FIRSTSYSCOLSLOTPTR-(i*SYSCOLSLOTSIZE)],SYSCOLSLOTSIZE);

		if(alreadyDeleted == '0')
		{
			cout<<"The entry is deleted... Don't search there.....";
			continue;
		}

		char * newEntryBuff = new char [SYSCOLUMNENTRYSIZE];

		memcpy(newEntryBuff,&sysColumnBuffer[0+(i*SYSCOLUMNENTRYSIZE)],SYSCOLUMNENTRYSIZE);

		char * colName = new char [64];
		char * tabName = new char [64];
		char * dataBaseName = new char [64];
		char * dataType = new char [8];

		memcpy(colName,&newEntryBuff[SYSCOLCOLNAMEPTR],64*sizeof(char));
		memcpy(tabName,&newEntryBuff[SYSCOLTABLENAMEPTR],64*sizeof(char));
		memcpy(dataBaseName,&newEntryBuff[SYSCOLDBNAMEPTR],64*sizeof(char));
		memcpy(dataType,&newEntryBuff[SYSCOLDATATYPEPTR],8*sizeof(char));

		string entryColumnName,entryTableName,entryDBName,entryDataType;
		for(int j=0;j<64;j++)
		{
			if(colName[j] == '$')
				break;
			entryColumnName = entryColumnName+colName[j];
		}
		for(int j=0;j<64;j++)
		{
			if(tabName[j] == '$')
				break;
			entryTableName = entryTableName+tabName[j];
		}
		for(int j=0;j<64;j++)
		{
			if(dataBaseName[j] == '$')
				break;
			entryDBName = entryDBName+dataBaseName[j];
		}
		for(int j=0;j<8;j++)
		{
			if(dataType[j] == '$')
				break;
			entryDataType = entryDataType+dataType[j];
		}

		if(columnName == entryColumnName && entryTableName == tableName && entryDBName == dbName && entryDataType == dataType)
		{
			found = 1;
			entryID = i;
			delete colName;
			delete tabName;
			delete dataBaseName;
			delete dataType;
			delete newEntryBuff;
			break;
		}

		delete colName;
		delete tabName;
		delete dataBaseName;
		delete dataType;
		delete newEntryBuff;
	}

	if(found == 0)
	{
		cout<<"Column not found... Continue searching..."<<endl;
		return -1;// Entry not found
	}

	return i+1; // SysColumnEntry found at (i+1)th Slot
}
